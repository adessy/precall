% Generated by roxygen2 (4.1.0): do not edit by hand
% Please edit documentation in R/precall.r
\name{aupr}
\alias{aupr}
\title{Compute the AUPR for precision-recall curves.}
\usage{
aupr(labels, scores)
}
\arguments{
\item{labels}{A vector of logical values that encodes the POSITIVE/NEGATIVE status of data}

\item{scores}{A matrix or vector of numeric values that specifies the rankings}
}
\value{
The vector of AUPR's.
}
\description{
Compute the Area Under the Precision-Recall curve (AUPR) for one or multiple precision-recall curves.
}
\details{
The \code{labels} encode the POSITIVE/NEGATIVE (\code{TRUE}/\code{FALSE}) status of data
while each column of \code{scores} provides scores corresponding to a ranking of those data:
a smaller score means a smaller rank.
A vector can be used as \code{scores} instead of a 1-column matrix to compute the AUPR of
only one ranking. If no \code{scores} are provided, it is assumed that the labels are already
sorted and the function computes the corresponding AUPR.

If \code{scores} is a k-column matrix, the function returns a vector of length k, otherwise it
returns a scalar.

The area is computed from precision-recall curves interpolated using the principle of partial
acceptance (see vignette \code{precall} for more details).
}
\examples{
labels = c(TRUE, FALSE, TRUE, FALSE, TRUE, TRUE, FALSE, FALSE) # 8 pieces of data

ranking1 = c(1,1,8,3,7,6,4,5)
ranking2 = c(4,6,3,3,2,5,6,6)
ranking3 = c(6,-1,3,3,2,4,1,5)

scores = cbind(ranking1, ranking2, ranking3)
colnames(scores) = c("method a", "method b", "method c")

# Implicit ranking
aupr(labels)
aupr(labels) == aupr(labels, seq_along(labels)) # is TRUE

# Explicit single ranking
aupr(labels, ranking1)

# Explicit multiple rankings
aupr(labels, scores)
}

